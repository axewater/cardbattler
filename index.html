<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Battler</title>
    <style>
        /* --- General Styles --- */
        body {
            font-family: sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            user-select: none; /* Prevent text selection during drags */
        }

        #game-container {
            width: 100%;
            max-width: 1200px;
            height: 90vh;
            max-height: 800px;
            background-color: #e0e0e0;
            border: 2px solid #333;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        /* --- Player Areas --- */
        .player-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            position: relative; /* For absolute positioning of hero */
        }

        #opponent-area {
            background-color: #c0c0c0;
            border-bottom: 2px dashed #888;
        }

        #player-area {
            background-color: #d0d0d0;
        }

        /* --- Board Area --- */
        .board {
            height: 160px; /* Fixed height for creature cards */
            background-color: rgba(0, 0, 0, 0.1);
            border: 1px solid #aaa;
            margin: 10px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 5px;
            min-height: 150px; /* Ensure it doesn't collapse */
            overflow-x: auto; /* Allow scrolling if many creatures */
        }

        #opponent-board { order: 1; }
        #player-board { order: 2; }


        /* --- Hand Area --- */
        .hand {
            height: 150px; /* Fixed height for hand cards */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            padding: 5px;
            overflow-x: auto; /* Allow scrolling if many cards */
             overflow-y: hidden;
        }

        #opponent-hand { order: 0; background: rgba(0,0,0,0.05); }
        #player-hand { order: 3; background: rgba(0,0,0,0.05);}

        /* --- Hero/Player Info --- */
        .hero-info {
            position: absolute;
            bottom: 10px; /* Position relative to player-area */
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #555;
            border-radius: 5px;
            padding: 5px 10px;
            text-align: center;
            min-width: 80px;
            z-index: 10; /* Above board/hand */
        }
        #opponent-area .hero-info {
            top: 10px;
            bottom: auto;
        }
        .hero-health {
            font-size: 1.2em;
            font-weight: bold;
            color: red;
        }
        .hero-mana {
            font-size: 1.1em;
            font-weight: bold;
            color: blue;
            margin-top: 4px;
        }
        .hero-deck {
            font-size: 0.9em;
            color: #333;
            margin-top: 4px;
        }


        /* --- Card Styles --- */
        .card {
            width: 80px;
            height: 120px;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: white;
            display: flex;
            flex-direction: column;
            padding: 4px;
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-size: 11px; /* Smaller base font for cards */
            position: relative; /* For pseudo-elements like cost/attack/health */
            overflow: hidden; /* Hide overflowing text */
            flex-shrink: 0; /* Prevent cards from shrinking in flex containers */
        }

        .card:hover {
            transform: scale(1.1);
            z-index: 100; /* Bring hovered card to front */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* Card positioning elements */
        .card-cost {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: blue;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            border: 1px solid white;
        }

        .card-name {
            font-weight: bold;
            text-align: center;
            margin-top: 2px;
            margin-bottom: 4px;
            font-size: 12px; /* Slightly larger for name */
            height: 15px; /* Limit name height */
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .card-effect {
            font-size: 10px; /* Smallest font for effect text */
            flex-grow: 1;
            margin: 2px 0;
            overflow-y: auto; /* Allow scrolling for long effects */
            line-height: 1.2;
            text-align: center;
        }

        .card-stats {
            display: flex;
            justify-content: space-between;
            margin-top: auto; /* Push stats to the bottom */
            padding: 0 2px; /* Spacing from edges */
        }

        .card-attack {
            position: absolute;
            bottom: 2px;
            left: 2px;
            background-color: orange;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            border: 1px solid white;
        }

        .card-health {
             position: absolute;
            bottom: 2px;
            right: 2px;
            background-color: red;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            border: 1px solid white;
        }

        /* Card Types */
        .card.Creature { background-color: #c8e6c9; } /* Light green */
        .card.Spell { background-color: #bbdefb; } /* Light blue */

        /* Opponent's hand card style (hidden) */
        #opponent-hand .card {
            background-color: #888;
            color: transparent;
            cursor: default;
        }
         #opponent-hand .card:hover {
            transform: none;
            box-shadow: none;
         }
        #opponent-hand .card .card-cost,
        #opponent-hand .card .card-attack,
        #opponent-hand .card .card-health,
        #opponent-hand .card .card-name,
        #opponent-hand .card .card-effect {
             visibility: hidden;
        }


        /* Card States */
        .card.playable {
            box-shadow: 0 0 10px 3px gold; /* Highlight playable cards */
        }
        .card.selected {
             box-shadow: 0 0 15px 5px blue;
             transform: scale(1.05) translateY(-10px);
        }
         .card.attacking {
             box-shadow: 0 0 15px 5px orange;
             transform: scale(1.05) translateY(-10px);
         }
        .card.targetable {
            outline: 3px dashed green;
        }
        .card.has-attacked {
             opacity: 0.7;
        }
         .card.can-attack {
             outline: 2px solid orange;
         }
        .card.is-taunt {
            border: 3px solid brown;
        }
        .card.is-frozen {
            box-shadow: inset 0 0 10px 5px lightblue;
        }

        /* --- Game Controls & Messages --- */
        #game-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
             z-index: 20;
        }

        #end-turn-button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            margin-bottom: 10px;
        }
        #end-turn-button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }

        #message-area {
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            padding: 5px;
            height: 25px; /* Fixed height for message area */
            background-color: rgba(255, 255, 255, 0.7);
        }

        /* --- Game Over Screen --- */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1000;
        }
        #game-over-overlay h2 {
            font-size: 3em;
            margin-bottom: 20px;
        }
        #restart-button {
             padding: 15px 30px;
            font-size: 1.5em;
            cursor: pointer;
        }

    </style>
</head>
<body>

    <div id="game-container">
        <!-- Opponent Area -->
        <div id="opponent-area" class="player-area">
            <div id="opponent-hero" class="hero-info">
                <div>Opponent</div>
                <div id="opponent-health" class="hero-health">30</div>
                <div id="opponent-mana" class="hero-mana">0/0</div>
                <div id="opponent-deck" class="hero-deck">Deck: 0</div>
            </div>
            <div id="opponent-hand" class="hand"></div>
            <div id="opponent-board" class="board"></div>
        </div>

        <!-- Message Area -->
        <div id="message-area">Game Starting...</div>

        <!-- Player Area -->
        <div id="player-area" class="player-area">
             <div id="player-hero" class="hero-info">
                <div>Player</div>
                <div id="player-health" class="hero-health">30</div>
                <div id="player-mana" class="hero-mana">0/0</div>
                <div id="player-deck" class="hero-deck">Deck: 0</div>
            </div>
            <div id="player-board" class="board"></div>
            <div id="player-hand" class="hand"></div>
        </div>

        <!-- Game Controls -->
        <div id="game-controls">
            <button id="end-turn-button" disabled>End Turn</button>
        </div>

         <!-- Game Over Overlay -->
        <div id="game-over-overlay">
            <h2 id="game-over-message"></h2>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        // --- Constants ---
        const MAX_MANA = 10;
        const STARTING_HEALTH = 30;
        const STARTING_HAND_SIZE = 4;
        const MAX_BOARD_SIZE = 7; // Max creatures on board

        // --- Card Definitions ---
        const cardLibrary = [
            // Common Creatures
            { id: "c1", name: "Eager Recruit", cost: 1, attack: 2, health: 1, type: "Creature", mechanics: [] },
            { id: "c2", name: "Forest Guardian", cost: 2, attack: 1, health: 3, type: "Creature", mechanics: ["Taunt"] },
            { id: "c3", name: "Flame Imp", cost: 1, attack: 3, health: 2, type: "Creature", mechanics: ["Deploy"], effectText: "Deploy: Deal 1 damage to yourself." },
            { id: "c4", name: "Nimble Scout", cost: 2, attack: 2, health: 2, type: "Creature", mechanics: ["Swift"] },
            { id: "c5", name: "Stone Defender", cost: 3, attack: 2, health: 4, type: "Creature", mechanics: [] },
            { id: "c6", name: "Healing Acolyte", cost: 2, attack: 1, health: 2, type: "Creature", mechanics: ["Deploy"], effectText: "Deploy: Restore 2 health to your hero." },
            { id: "c7", name: "Raging Berserker", cost: 3, attack: 3, health: 3, type: "Creature", mechanics: ["Frenzy"], effectText: "Frenzy: Gains +2 Atk when damaged." }, // Frenzy not implemented
            { id: "c8", name: "Shadow Stalker", cost: 4, attack: 3, health: 3, type: "Creature", mechanics: ["Stealth"], effectText: "Stealth (1 turn)" }, // Stealth not implemented

            // Rare Creatures
            { id: "r1", name: "Arcane Scholar", cost: 4, attack: 2, health: 4, type: "Creature", mechanics: ["Spell Power +1"], effectText: "Spell Power +1" }, // Spell Power not implemented
            { id: "r2", name: "War Golem", cost: 6, attack: 6, health: 6, type: "Creature", mechanics: [] },
            { id: "r3", name: "Battlefield Commander", cost: 5, attack: 4, health: 4, type: "Creature", mechanics: ["Aura"], effectText: "Aura: Your other creatures have +1 Attack." }, // Aura not implemented
            { id: "r4", name: "Venomous Spider", cost: 3, attack: 2, health: 3, type: "Creature", mechanics: ["Poison"], effectText: "Poison: Damages creature at end of turn." }, // Poison not implemented

            // Spells --- ADD mechanics: [] TO EACH ---
            { id: "s1", name: "Fireball", cost: 3, type: "Spell", target: "any", mechanics: [], effectText: "Deal 4 damage.", action: (target) => dealDamage(target, 4) },
            { id: "s2", name: "Healing Touch", cost: 2, type: "Spell", target: "any", mechanics: [], effectText: "Restore 4 health.", action: (target) => restoreHealth(target, 4) },
            { id: "s3", name: "Battle Rage", cost: 1, type: "Spell", target: "creature", mechanics: [], effectText: "Give a creature +2 Attack until end of turn.", action: (target) => temporaryBuff(target, 2, 0) }, // Temp buff not fully implemented (lasts forever currently)
            { id: "s4", name: "Frost Nova", cost: 4, type: "Spell", target: "opponent-board", mechanics: [], effectText: "Freeze all enemy creatures.", action: freezeBoard }, // Freeze not implemented
            { id: "s5", name: "Arcane Intellect", cost: 3, type: "Spell", target: "self", mechanics: [], effectText: "Draw 2 cards.", action: (player) => { drawCard(player); drawCard(player); } },
            { id: "s6", name: "Shield Wall", cost: 2, type: "Spell", target: "creature", mechanics: [], effectText: "Give a creature +0/+3.", action: (target) => permanentBuff(target, 0, 3) },
            { id: "s7", name: "Lightning Bolt", cost: 2, type: "Spell", target: "creature", mechanics: [], effectText: "Deal 3 damage to a creature.", action: (target) => dealDamage(target, 3) },

            // Legendary Card
            { id: "l1", name: "Dragon Lord", cost: 8, attack: 7, health: 7, type: "Creature", mechanics: ["Deploy"], effectText: "Deploy: Summon a 3/3 Dragon Whelp." }, // Whelp summon not implemented
        ];

        // --- Game State ---
        let state = {};

        // --- DOM Elements ---
        const opponentHealthEl = document.getElementById('opponent-health');
        const opponentManaEl = document.getElementById('opponent-mana');
        const opponentDeckEl = document.getElementById('opponent-deck');
        const opponentHandEl = document.getElementById('opponent-hand');
        const opponentBoardEl = document.getElementById('opponent-board');

        const playerHealthEl = document.getElementById('player-health');
        const playerManaEl = document.getElementById('player-mana');
        const playerDeckEl = document.getElementById('player-deck');
        const playerHandEl = document.getElementById('player-hand');
        const playerBoardEl = document.getElementById('player-board');

        const messageAreaEl = document.getElementById('message-area');
        const endTurnButton = document.getElementById('end-turn-button');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const gameOverMessage = document.getElementById('game-over-message');
        const restartButton = document.getElementById('restart-button');


        // --- Game Logic Functions ---

        function createCardInstance(cardData, ownerId) {
            // Create a unique instance of a card from the library
            return {
                ...cardData,
                instanceId: generateId(),
                owner: ownerId,
                currentHealth: cardData.health, // Add current health for creatures
                currentAttack: cardData.attack, // Add current attack
                canAttack: false,             // Can it attack this turn?
                hasAttacked: false,           // Has it attacked this turn?
                isFrozen: false,              // Frozen state
                effects: [],                  // For temporary effects, statuses etc.
                isTaunt: cardData.mechanics.includes("Taunt"),
                isSwift: cardData.mechanics.includes("Swift"),
                // Add more state as needed (isStealthed, poisonCounters, etc.)
            };
        }

        function generateId() {
            return Math.random().toString(36).substring(2, 9);
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function initGame() {
            console.log("Initializing game...");
            // Reset state
            state = {
                players: {
                    player: {
                        id: 'player',
                        heroHealth: STARTING_HEALTH,
                        maxMana: 0,
                        currentMana: 0,
                        deck: [],
                        hand: [],
                        board: [],
                        heroElement: document.getElementById('player-hero'),
                        healthElement: playerHealthEl,
                        manaElement: playerManaEl,
                        deckElement: playerDeckEl,
                        handElement: playerHandEl,
                        boardElement: playerBoardEl,
                    },
                    opponent: {
                        id: 'opponent',
                        heroHealth: STARTING_HEALTH,
                        maxMana: 0,
                        currentMana: 0,
                        deck: [],
                        hand: [],
                        board: [],
                        heroElement: document.getElementById('opponent-hero'),
                        healthElement: opponentHealthEl,
                        manaElement: opponentManaEl,
                        deckElement: opponentDeckEl,
                        handElement: opponentHandEl,
                        boardElement: opponentBoardEl,
                    }
                },
                currentPlayerId: 'player',
                turn: 0,
                gameOver: false,
                message: "",
                selectedCard: null, // { card, location: 'hand'/'board' }
                selectedAttacker: null, // instanceId of creature attacking
                targetingMode: null, // 'spell', 'attack'
                spellTargetType: null // 'any', 'creature', 'opponent-board', 'self'
            };

            // Build decks (simple example: give each player a mix)
            const playerCards = [];
            const opponentCards = [];
            // Simplistic deck building: just add multiple copies
            for (let i = 0; i < 2; i++) {
                 cardLibrary.forEach(card => {
                    playerCards.push(createCardInstance(card, 'player'));
                    opponentCards.push(createCardInstance(card, 'opponent'));
                 });
            }

            state.players.player.deck = playerCards;
            state.players.opponent.deck = opponentCards;

            shuffleDeck(state.players.player.deck);
            shuffleDeck(state.players.opponent.deck);

            // Draw initial hands
            for (let i = 0; i < STARTING_HAND_SIZE; i++) {
                drawCard(state.players.player);
                drawCard(state.players.opponent);
            }

            // Hide game over screen
            gameOverOverlay.style.display = 'none';

            // Start the first turn
            startTurn('player');

            console.log("Game Initialized:", state);
        }

        function drawCard(player) {
            if (player.deck.length > 0 && player.hand.length < 10) { // Max hand size 10
                const card = player.deck.pop();
                player.hand.push(card);
                console.log(`${player.id} drew ${card.name}`);
            } else if (player.deck.length === 0) {
                // Fatigue damage could be implemented here
                console.log(`${player.id} deck empty!`);
                // Deal fatigue damage (example: 1 damage, increasing each time)
                 player.fatigue = (player.fatigue || 0) + 1;
                 dealDamage(player.heroElement, player.fatigue);
                 setMessage(`${player.id} is out of cards and takes ${player.fatigue} fatigue damage!`);
            } else {
                 console.log(`${player.id} hand full! Card burned.`);
                 player.deck.pop(); // Burn the card
                 setMessage(`${player.id}'s hand is full! Card burned.`);
            }
            // No need to re-render here, startTurn/endTurn calls render
        }

        function startTurn(playerId) {
            state.turn++;
            state.currentPlayerId = playerId;
            const player = state.players[playerId];
            console.log(`--- Turn ${state.turn}: ${playerId} ---`);

             // Reset selections
            deselectCard();
            deselectAttacker();
            state.targetingMode = null;

            // Increase Max Mana (up to MAX_MANA)
            if (player.maxMana < MAX_MANA) {
                player.maxMana++;
            }
            // Refill Mana
            player.currentMana = player.maxMana;

             // Set creatures to be able to attack (reset summoning sickness if not just played)
             // Also reset attack count
            player.board.forEach(creature => {
                creature.canAttack = !creature.justPlayed && !creature.isFrozen; // Can attack if not just played/frozen
                creature.hasAttacked = false;
                if(creature.justPlayed) creature.justPlayed = false; // Remove summoning sickness for next turn
                if(creature.isFrozen) creature.isFrozen = false; // Unfreeze at start of turn
            });
            state.players[getOpponentId(playerId)].board.forEach(creature => {
                // Reset temporary buffs etc. if needed here
            });


            // Draw a card
            drawCard(player);

            // Update UI
            renderGame();
            updatePlayableCards(player);

            setMessage(`${playerId}'s turn.`);
            endTurnButton.disabled = playerId !== 'player'; // Enable button only for player


            // If it's the AI's turn, run its logic
            if (playerId === 'opponent') {
                // Disable player actions during AI turn
                setMessage("Opponent's turn...");
                setTimeout(runAITurn, 1000); // Add slight delay for visibility
            }
        }

        function endTurn() {
             const currentPlayer = state.players[state.currentPlayerId];
            console.log(`${currentPlayer.id} ends turn.`);

            // --- End of Turn Effects ---
            // Example: Poison (if implemented)
            // currentPlayer.board.forEach(c => { if(c.isPoisoned) dealDamage(c, 1); });
            // state.players[getOpponentId(currentPlayer.id)].board.forEach(c => { if(c.isPoisoned) dealDamage(c, 1); });


            if (state.gameOver) return;

            const nextPlayerId = getOpponentId(state.currentPlayerId);
            startTurn(nextPlayerId);
        }

         function checkWinCondition() {
            const player = state.players.player;
            const opponent = state.players.opponent;

            if (player.heroHealth <= 0) {
                gameOver("Opponent Wins!");
                return true;
            }
            if (opponent.heroHealth <= 0) {
                gameOver("Player Wins!");
                return true;
            }
            return false;
        }

         function gameOver(message) {
            console.log("Game Over:", message);
            state.gameOver = true;
            state.message = message;
            setMessage(message);
            gameOverMessage.textContent = message;
            gameOverOverlay.style.display = 'flex';
            endTurnButton.disabled = true;
        }

        function playCard(player, card, cardIndexInHand, targetElement) {
            console.log(`${player.id} attempts to play ${card.name}`);

             // Basic checks
            if (player.currentMana < card.cost) {
                setMessage("Not enough mana!");
                console.log("Not enough mana");
                return;
            }
            if (card.type === "Creature" && player.board.length >= MAX_BOARD_SIZE) {
                 setMessage("Board is full!");
                 console.log("Board is full");
                 return;
            }

             // Deduct mana first
            player.currentMana -= card.cost;

             // Remove card from hand
            player.hand.splice(cardIndexInHand, 1);

            // --- Play the card ---
            if (card.type === "Creature") {
                console.log(`Playing creature: ${card.name}`);
                card.justPlayed = true; // Has summoning sickness (unless Swift)
                card.canAttack = card.isSwift; // Can attack immediately if Swift
                player.board.push(card);

                // Handle Deploy effects
                if (card.mechanics.includes("Deploy")) {
                    triggerDeployEffect(player, card);
                }

            } else if (card.type === "Spell") {
                console.log(`Playing spell: ${card.name}`);
                 if (card.action) {
                    const target = getTargetFromElement(targetElement, card.target, player);
                    if(target !== "invalid") { // Check if target is valid for the spell
                         console.log("Executing spell action on target:", target);
                         try {
                            card.action(target, player); // Pass player context if needed (e.g., for Arcane Intellect)
                         } catch (e) {
                             console.error("Error executing spell action:", e);
                             // Maybe refund mana or handle error? For now, log it.
                         }
                    } else {
                        console.log("Invalid target for spell.");
                        // Refund mana? Put card back? For now, spell fizzles.
                        setMessage("Invalid target for spell.");
                        // Put card back in hand and refund mana (simple rollback)
                        player.hand.splice(cardIndexInHand, 0, card);
                        player.currentMana += card.cost;
                        renderGame();
                        return; // Stop further processing
                    }
                } else {
                     console.log(`Spell ${card.name} has no defined action.`);
                 }
                // Spells usually go to a graveyard, but we'll just remove it for simplicity
            }

             // Check win condition immediately after potential damage/healing
             if (checkWinCondition()) return;

             // Update UI after playing
             deselectCard(); // Clear selection
             renderGame();
             updatePlayableCards(player);
        }

        function getTargetFromElement(element, targetType, caster) {
             if (!element && (targetType === 'creature' || targetType === 'any')) {
                 console.log("Target required but none provided.");
                 return "invalid"; // Requires a specific target but none given
             }
             if (targetType === 'self') return caster;
             if (targetType === 'opponent-board') return state.players[getOpponentId(caster.id)].board; // Target the whole board

             const cardInstanceId = element ? element.dataset.instanceId : null;
             const targetPlayerId = element ? element.closest('.player-area').id.split('-')[0] : null; // 'player' or 'opponent'

             if (element && element.classList.contains('hero-info')) { // Targeting a hero
                 if (targetType === 'any' || (targetType === 'hero')) {
                     return element; // Return the hero element itself for targeting
                 } else {
                     return "invalid"; // Can't target hero if spell needs creature
                 }
             } else if (cardInstanceId) { // Targeting a creature
                 const targetPlayer = state.players[targetPlayerId];
                 const targetCard = targetPlayer.board.find(c => c.instanceId === cardInstanceId);
                 if (targetCard && (targetType === 'any' || targetType === 'creature')) {
                     return targetCard;
                 } else {
                     return "invalid"; // Found element but it's not a valid creature target
                 }
             }

             return "invalid"; // Default if no valid target found
        }


        function creatureAttack(attackerCard, targetElement) {
             const opponentPlayer = state.players[getOpponentId(attackerCard.owner)];
             const targetInstanceId = targetElement ? targetElement.dataset.instanceId : null;

             let target; // Can be a card object or a hero element

             // Determine target
            if (targetElement && targetElement.classList.contains('hero-info')) {
                // Target is the opponent hero
                 // Check for Taunt minions first
                const tauntMinions = opponentPlayer.board.filter(c => c.isTaunt);
                if (tauntMinions.length > 0) {
                    setMessage("Must attack a Taunt creature!");
                    console.log("Attack blocked by Taunt");
                    deselectAttacker();
                    renderGame();
                    return;
                }
                 target = opponentPlayer.heroElement;
                 console.log(`${attackerCard.name} attacks ${opponentPlayer.id} hero`);
            } else if (targetInstanceId) {
                // Target is a creature
                target = opponentPlayer.board.find(c => c.instanceId === targetInstanceId);
                 if (!target) {
                     console.error("Target creature not found!");
                     deselectAttacker();
                     renderGame();
                     return; // Target doesn't exist anymore
                 }
                console.log(`${attackerCard.name} attacks ${target.name}`);
            } else {
                console.error("Invalid attack target element.");
                 deselectAttacker();
                 renderGame();
                return;
            }

             // Execute Combat
             if (target && attackerCard.currentAttack > 0) { // Check if attacker has attack power
                dealDamage(target, attackerCard.currentAttack);
             }
             // Creature vs Creature retaliation damage
            if (target && target.type === 'Creature' && target.currentAttack > 0) {
                 dealDamage(attackerCard, target.currentAttack);
            }

             attackerCard.hasAttacked = true;
             attackerCard.canAttack = false; // Cannot attack again this turn

             // Check win condition after combat
             if (checkWinCondition()) return;

             // Update UI
             deselectAttacker();
             renderGame();
             updatePlayableCards(state.players[state.currentPlayerId]); // Re-check playable cards potentially
        }

        function dealDamage(target, amount) {
            if (amount <= 0) return; // No damage dealt

            if (target instanceof HTMLElement && target.classList.contains('hero-info')) { // Target is Hero
                const playerId = target.id.includes('player') ? 'player' : 'opponent';
                const player = state.players[playerId];
                player.heroHealth -= amount;
                console.log(`Hero ${playerId} takes ${amount} damage. Health: ${player.heroHealth}`);
                if (player.heroHealth < 0) player.heroHealth = 0; // Don't go below 0
                // Add visual feedback (e.g., flash red)
                target.style.transition = 'background-color 0.1s ease-in-out';
                target.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                setTimeout(() => { target.style.backgroundColor = 'rgba(255, 255, 255, 0.8)'; }, 200);

            } else if (target && typeof target === 'object' && target.instanceId) { // Target is Creature
                target.currentHealth -= amount;
                console.log(`Creature ${target.name} (${target.instanceId}) takes ${amount} damage. Health: ${target.currentHealth}`);
                 // Add visual feedback
                 const cardEl = document.querySelector(`.card[data-instance-id="${target.instanceId}"]`);
                 if (cardEl) {
                     cardEl.style.transition = 'transform 0.1s ease-in-out';
                     cardEl.style.transform = 'scale(0.95)';
                     setTimeout(() => { cardEl.style.transform = 'scale(1)'; }, 100);
                 }

                // Check for death
                if (target.currentHealth <= 0) {
                    console.log(`Creature ${target.name} (${target.instanceId}) died.`);
                    removeCreatureFromBoard(target);
                } else {
                     // Trigger Frenzy? (Not implemented)
                }
            } else {
                 console.warn("dealDamage called with invalid target:", target);
             }
            // Re-rendering happens in the calling function (playCard/creatureAttack)
        }

        function restoreHealth(target, amount) {
             if (target instanceof HTMLElement && target.classList.contains('hero-info')) { // Target is Hero
                const playerId = target.id.includes('player') ? 'player' : 'opponent';
                const player = state.players[playerId];
                player.heroHealth += amount;
                 if (player.heroHealth > STARTING_HEALTH) player.heroHealth = STARTING_HEALTH; // Cap at max health
                console.log(`Hero ${playerId} restores ${amount} health. Health: ${player.heroHealth}`);

            } else if (target && typeof target === 'object' && target.instanceId) { // Target is Creature
                target.currentHealth += amount;
                 if (target.currentHealth > target.health) target.currentHealth = target.health; // Cap at max health
                console.log(`Creature ${target.name} restores ${amount} health. Health: ${target.currentHealth}`);
            } else {
                 console.warn("restoreHealth called with invalid target:", target);
            }
            // Re-rendering happens in the calling function (playCard)
        }

         function permanentBuff(targetCard, attackBuff, healthBuff) {
             if (targetCard && targetCard.type === 'Creature') {
                 targetCard.currentAttack += attackBuff;
                 targetCard.currentHealth += healthBuff;
                 targetCard.health += healthBuff; // Increase max health as well for permanent buff
                 if (targetCard.currentAttack < 0) targetCard.currentAttack = 0; // Attack can't be negative
                 console.log(`${targetCard.name} gets +${attackBuff}/+${healthBuff}. Stats: ${targetCard.currentAttack}/${targetCard.currentHealth}`);
             } else {
                 console.warn("permanentBuff target is not a creature:", targetCard);
             }
         }
         function temporaryBuff(targetCard, attackBuff, healthBuff) {
            // Simple implementation - lasts forever currently.
            // Real implementation would need tracking and removal at end of turn.
            permanentBuff(targetCard, attackBuff, healthBuff);
            // Add effect to card.effects list to be cleared later
            console.log(`Applied temporary buff to ${targetCard.name} (needs end-of-turn clearing)`);
         }

         function freezeBoard(board) {
            // Needs implementation: Mark all creatures on the target board as frozen
             console.warn("Freeze effect not implemented!");
             // Example:
             // board.forEach(creature => creature.isFrozen = true);
             setMessage("Freeze effect not fully implemented.");
         }


        function removeCreatureFromBoard(creature) {
            const owner = state.players[creature.owner];
            owner.board = owner.board.filter(c => c.instanceId !== creature.instanceId);
            // Could add to a graveyard pile if needed
        }

        function triggerDeployEffect(player, card) {
             console.log(`Triggering Deploy effect for ${card.name}`);
             // Implement specific deploy effects based on card.id or effectText
             switch (card.id) {
                 case 'c3': // Flame Imp
                     dealDamage(player.heroElement, 1);
                     break;
                 case 'c6': // Healing Acolyte
                     restoreHealth(player.heroElement, 2);
                     break;
                 case 'l1': // Dragon Lord
                     console.warn("Dragon Lord Whelp summoning not implemented.");
                    // Example: if (player.board.length < MAX_BOARD_SIZE) {
                    //    const whelpData = { id: "whelp", name: "Dragon Whelp", cost: 0, attack: 3, health: 3, type: "Creature", mechanics: [] };
                    //    const whelpInstance = createCardInstance(whelpData, player.id);
                    //    whelpInstance.justPlayed = true; // Summoning sickness
                     //   player.board.push(whelpInstance);
                    // }
                     break;
                 // Add other deploy effects here
             }
             // Deploy effects might trigger other events, re-render might be needed
        }

        // --- UI Rendering ---

        function renderGame() {
            console.log("Rendering game state...");
            if (state.gameOver) return; // Don't render if game over is showing

            // Render Player Stats
            renderPlayerInfo(state.players.player);
            renderPlayerInfo(state.players.opponent);

            // Render Hands
            renderHand(state.players.player);
            renderHand(state.players.opponent);

            // Render Boards
            renderBoard(state.players.player);
            renderBoard(state.players.opponent);

            // Update Message
            setMessage(state.message || `${state.currentPlayerId}'s turn.`);

            // Update Button State
            endTurnButton.disabled = state.currentPlayerId !== 'player' || state.targetingMode !== null;

            // Highlight targetable entities if needed
            updateTargetHighlights();
        }

         function renderPlayerInfo(player) {
            player.healthElement.textContent = player.heroHealth;
            player.manaElement.textContent = `${player.currentMana}/${player.maxMana}`;
            player.deckElement.textContent = `Deck: ${player.deck.length}`;
         }

        function renderHand(player) {
            player.handElement.innerHTML = ''; // Clear current hand
            player.hand.forEach((card, index) => {
                const cardEl = createCardElement(card, 'hand', index);
                player.handElement.appendChild(cardEl);
            });
        }

        function renderBoard(player) {
            player.boardElement.innerHTML = ''; // Clear current board
            player.board.forEach(card => {
                const cardEl = createCardElement(card, 'board');
                player.boardElement.appendChild(cardEl);
            });
        }

        function createCardElement(card, location, indexInHand = -1) {
            const cardEl = document.createElement('div');
            cardEl.classList.add('card', card.type);
            cardEl.dataset.instanceId = card.instanceId; // Store unique ID
            cardEl.dataset.cardId = card.id; // Store library ID
            if(location === 'hand') cardEl.dataset.handIndex = indexInHand;
            if(location === 'board') cardEl.dataset.owner = card.owner;

            // Add state classes
            if (location === 'hand' && state.currentPlayerId === card.owner && card.cost <= state.players[card.owner].currentMana) {
                 // Basic check, full check in updatePlayableCards
            }
            if (card.isTaunt) cardEl.classList.add('is-taunt');
            if (card.canAttack && location === 'board' && card.owner === state.currentPlayerId) cardEl.classList.add('can-attack');
            if (card.hasAttacked) cardEl.classList.add('has-attacked');
            if (card.isFrozen) cardEl.classList.add('is-frozen');

            // Card Content
            let effectText = card.effectText || "";
            if (card.mechanics.length > 0 && !effectText) {
                effectText = card.mechanics.join(', ');
            } else if (card.mechanics.length > 0) {
                effectText = `<b>${card.mechanics.join(', ')}</b>. ${effectText}`;
            }

            cardEl.innerHTML = `
                <div class="card-cost">${card.cost}</div>
                <div class="card-name">${card.name}</div>
                ${card.type === 'Creature' ? `<div class="card-attack">${card.currentAttack !== undefined ? card.currentAttack : card.attack}</div>` : ''}
                ${card.type === 'Creature' ? `<div class="card-health">${card.currentHealth !== undefined ? card.currentHealth : card.health}</div>` : ''}
                <div class="card-effect">${effectText}</div>
            `;


            // Add event listeners only for the player's cards/board
            if (card.owner === 'player' && !state.gameOver) {
                if (location === 'hand') {
                    cardEl.addEventListener('click', () => handleHandCardClick(card, indexInHand));
                } else if (location === 'board') {
                     cardEl.addEventListener('click', () => handleBoardCardClick(card));
                }
            }
             // Add targeting listeners for opponent's stuff (even if owned by opponent)
            if (location === 'board' && card.owner === 'opponent') {
                 cardEl.addEventListener('click', () => handleTargetClick(cardEl));
             }


            return cardEl;
        }

        function setMessage(msg) {
            messageAreaEl.textContent = msg;
        }

        function updatePlayableCards(player) {
            // Remove existing playable class
            player.handElement.querySelectorAll('.card').forEach(el => el.classList.remove('playable'));

            if (player.id !== state.currentPlayerId) return; // Only highlight for current player

            player.hand.forEach((card, index) => {
                 let canPlay = player.currentMana >= card.cost;
                 if (card.type === "Creature" && player.board.length >= MAX_BOARD_SIZE) {
                     canPlay = false; // Cannot play if board is full
                 }

                 if (canPlay) {
                    const cardEl = player.handElement.querySelector(`.card[data-hand-index="${index}"]`);
                    if (cardEl) cardEl.classList.add('playable');
                 }
            });
        }

         function updateTargetHighlights() {
             // Clear previous highlights
            document.querySelectorAll('.targetable').forEach(el => el.classList.remove('targetable'));

             if (!state.targetingMode) return; // Only highlight when targeting

             const player = state.players[state.currentPlayerId];
             const opponent = state.players[getOpponentId(state.currentPlayerId)];

             const canTarget = (targetCard, targetType) => {
                 if (!targetCard) return false; // Safety check
                 if (targetType === 'any') return true;
                 if (targetType === 'creature' && targetCard.type === 'Creature') return true;
                // Add more checks (e.g., cannot target stealthed)
                 return false;
             };
              const canTargetHero = (heroElement, targetType) => {
                  if (targetType === 'any' || targetType === 'hero') return true;
                  return false;
              }


             if (state.targetingMode === 'spell') {
                 const spell = state.selectedCard.card;
                 // Highlight player creatures/hero
                 if (canTargetHero(player.heroElement, spell.target)) player.heroElement.classList.add('targetable');
                 player.board.forEach(card => {
                     if (canTarget(card, spell.target)) {
                         const el = player.boardElement.querySelector(`.card[data-instance-id="${card.instanceId}"]`);
                         if (el) el.classList.add('targetable');
                     }
                 });
                 // Highlight opponent creatures/hero
                  if (canTargetHero(opponent.heroElement, spell.target)) opponent.heroElement.classList.add('targetable');
                 opponent.board.forEach(card => {
                     if (canTarget(card, spell.target)) {
                         const el = opponent.boardElement.querySelector(`.card[data-instance-id="${card.instanceId}"]`);
                         if (el) el.classList.add('targetable');
                     }
                 });
             } else if (state.targetingMode === 'attack') {
                  // Highlight opponent creatures/hero that can be attacked
                 const tauntMinions = opponent.board.filter(c => c.isTaunt);
                 if (tauntMinions.length > 0) {
                     // Only highlight taunt minions
                     tauntMinions.forEach(card => {
                         const el = opponent.boardElement.querySelector(`.card[data-instance-id="${card.instanceId}"]`);
                         if (el) el.classList.add('targetable');
                     });
                 } else {
                     // Highlight all opponent creatures and hero
                     opponent.board.forEach(card => {
                         const el = opponent.boardElement.querySelector(`.card[data-instance-id="${card.instanceId}"]`);
                         if (el) el.classList.add('targetable');
                     });
                     opponent.heroElement.classList.add('targetable');
                 }
             }
         }

        // --- Event Handlers ---
        function handleHandCardClick(card, index) {
             console.log(`Clicked hand card: ${card.name} at index ${index}`);
            const player = state.players.player; // Only player can click their hand

            if (state.currentPlayerId !== 'player') return; // Not player's turn
            if (state.targetingMode) return; // Cannot select new card while targeting

             if (state.selectedCard && state.selectedCard.card.instanceId === card.instanceId) {
                // Clicked the same card again, deselect
                deselectCard();
            } else {
                // Select this card
                 deselectCard(); // Deselect previous if any
                 if (player.currentMana >= card.cost) {
                    const cardEl = player.handElement.querySelector(`.card[data-hand-index="${index}"]`);
                    if(cardEl) {
                        cardEl.classList.add('selected');
                        state.selectedCard = { card: card, location: 'hand', index: index };

                         // Determine next action based on card type
                        if (card.type === 'Creature') {
                            // Play immediately (no target needed initially)
                             playCard(player, card, index);
                             // deselectCard() is called within playCard
                         } else if (card.type === 'Spell') {
                            // Enter targeting mode if the spell requires it
                            if (card.target && card.target !== 'self' && card.target !== 'opponent-board') { // Needs specific target
                                state.targetingMode = 'spell';
                                state.spellTargetType = card.target;
                                setMessage(`Select a target for ${card.name}`);
                                updateTargetHighlights();
                             } else {
                                 // Play spell immediately (targets self or whole board)
                                 playCard(player, card, index, null); // Pass null target for self/board spells
                                 // deselectCard() called within playCard
                             }
                        }
                    }
                 } else {
                    setMessage("Not enough mana!");
                 }
            }
            renderGame(); // Update UI with selection/deselection
            updatePlayableCards(player);
        }

        function handleBoardCardClick(card) {
             console.log(`Clicked board card: ${card.name} (${card.instanceId})`);
            const player = state.players.player;

            if (state.currentPlayerId !== 'player') return; // Not player's turn

             if (state.targetingMode === 'spell') {
                 // Clicked own creature while targeting for a spell
                 const spell = state.selectedCard.card;
                 const targetElement = player.boardElement.querySelector(`.card[data-instance-id="${card.instanceId}"]`);
                 if (targetElement && targetElement.classList.contains('targetable')) {
                     playCard(player, spell, state.selectedCard.index, targetElement);
                     // deselectCard/renderGame called within playCard
                 } else {
                     setMessage("Invalid target for spell.");
                     // Maybe deselect spell here? For now, do nothing.
                 }
             } else if (state.targetingMode === 'attack') {
                 // Clicked own creature while selecting target for attack - invalid action
                 setMessage("Select an enemy target to attack.");
                 // Maybe deselect attacker? For now, do nothing.
             }
            else {
                 // No targeting active, try selecting this creature for attack
                 deselectAttacker(); // Deselect previous attacker if any
                 deselectCard();    // Deselect any hand card

                 if (card.canAttack && !card.hasAttacked && !card.isFrozen) {
                    const cardEl = player.boardElement.querySelector(`.card[data-instance-id="${card.instanceId}"]`);
                     if(cardEl) {
                         cardEl.classList.add('attacking');
                         state.selectedAttacker = card;
                         state.targetingMode = 'attack';
                         setMessage(`Select target for ${card.name} to attack.`);
                         updateTargetHighlights();
                     }
                 } else if (card.hasAttacked) {
                     setMessage(`${card.name} has already attacked this turn.`);
                 } else if (card.isFrozen) {
                     setMessage(`${card.name} is frozen.`);
                 } else {
                     setMessage(`${card.name} cannot attack yet (Summoning Sickness?).`);
                 }
            }
            renderGame(); // Update highlights etc.
        }

        function handleTargetClick(targetElement) {
            console.log("Clicked target element:", targetElement);
            const player = state.players.player;

            if (state.currentPlayerId !== 'player') return; // Should not happen if event listeners are correct
            if (!state.targetingMode) return; // Not targeting

             if (!targetElement.classList.contains('targetable')) {
                setMessage("Invalid target.");
                // Consider deselecting spell/attacker here if needed
                return;
             }

            if (state.targetingMode === 'spell') {
                const spell = state.selectedCard.card;
                playCard(player, spell, state.selectedCard.index, targetElement);
                 // deselectCard/renderGame called within playCard
            } else if (state.targetingMode === 'attack') {
                 const attacker = state.selectedAttacker;
                creatureAttack(attacker, targetElement);
                 // deselectAttacker/renderGame called within creatureAttack
            }
        }

        function handleHeroClick(heroElement) {
            console.log("Clicked hero:", heroElement.id);
            const player = state.players.player;
            const opponent = state.players.opponent;

             if (state.currentPlayerId !== 'player' || !state.targetingMode) return;

              if (!heroElement.classList.contains('targetable')) {
                 if(state.targetingMode === 'attack') setMessage("Cannot target hero (maybe Taunt is active?).");
                 else setMessage("Invalid target.");
                 return;
              }

            if (state.targetingMode === 'spell') {
                 const spell = state.selectedCard.card;
                 playCard(player, spell, state.selectedCard.index, heroElement);
                 // deselectCard/renderGame called within playCard
            } else if (state.targetingMode === 'attack') {
                 const attacker = state.selectedAttacker;
                 creatureAttack(attacker, heroElement);
                 // deselectAttacker/renderGame called within creatureAttack
            }
        }


        function deselectCard() {
            if (state.selectedCard) {
                const player = state.players[state.selectedCard.card.owner];
                const cardEl = player.handElement.querySelector(`.card[data-instance-id="${state.selectedCard.card.instanceId}"]`);
                if (cardEl) cardEl.classList.remove('selected');
                state.selectedCard = null;
                 if (state.targetingMode === 'spell') {
                    state.targetingMode = null;
                    setMessage(`${state.currentPlayerId}'s turn.`); // Reset message
                     updateTargetHighlights(); // Clear target highlights
                 }
            }
        }
        function deselectAttacker() {
             if (state.selectedAttacker) {
                 const player = state.players[state.selectedAttacker.owner];
                 const cardEl = player.boardElement.querySelector(`.card[data-instance-id="${state.selectedAttacker.instanceId}"]`);
                if (cardEl) cardEl.classList.remove('attacking');
                state.selectedAttacker = null;
                 if (state.targetingMode === 'attack') {
                    state.targetingMode = null;
                     setMessage(`${state.currentPlayerId}'s turn.`); // Reset message
                    updateTargetHighlights(); // Clear target highlights
                 }
             }
        }

        function getOpponentId(playerId) {
            return playerId === 'player' ? 'opponent' : 'player';
        }

        // --- AI Logic ---
        function runAITurn() {
             console.log("--- AI Turn Start ---");
            const aiPlayer = state.players.opponent;
            const humanPlayer = state.players.player;

             if (state.gameOver) return;

             // Simple AI:
            // 1. Play cards if possible (prioritize higher cost?)
            // 2. Attack with available creatures (prioritize creatures over hero?)

             let actionsTaken = 0;
             const maxActions = 15; // Safety break to prevent infinite loops

             function performAIAction() {
                if (state.gameOver || state.currentPlayerId !== 'opponent' || actionsTaken++ > maxActions) {
                    if(!state.gameOver) {
                         console.log("--- AI Turn End ---");
                         endTurn(); // End turn if no more actions or loop break
                    }
                     return;
                }

                let actionFound = false;

                 // Try to play a card
                 const playableCards = aiPlayer.hand.filter(card =>
                     card.cost <= aiPlayer.currentMana &&
                     !(card.type === "Creature" && aiPlayer.board.length >= MAX_BOARD_SIZE)
                 ).sort((a, b) => b.cost - a.cost); // Prioritize playing higher cost cards


                 if (playableCards.length > 0) {
                     const cardToPlay = playableCards[0]; // Play the highest cost possible card
                     const cardIndex = aiPlayer.hand.findIndex(c => c.instanceId === cardToPlay.instanceId);

                     console.log(`AI considering playing: ${cardToPlay.name}`);

                     if (cardToPlay.type === "Creature") {
                         // Play creature directly
                         playCard(aiPlayer, cardToPlay, cardIndex);
                         actionFound = true;
                     } else if (cardToPlay.type === "Spell") {
                         let targetElement = null;
                         // Basic AI targeting for spells
                        if (cardToPlay.target === 'self' || cardToPlay.target === 'opponent-board') {
                             playCard(aiPlayer, cardToPlay, cardIndex, null); // Self or board target
                             actionFound = true;
                         } else {
                             // Needs specific target (creature or any) - very basic targeting
                             let potentialTargets = [];
                              if (cardToPlay.target === 'creature' || cardToPlay.target === 'any') {
                                  // Prioritize damaging enemy creatures, then enemy hero (if 'any'), then maybe buffing own?
                                 // Very simple: Target highest health enemy creature first for damage spells
                                 // Target lowest health own creature for healing/buffs
                                 if (cardToPlay.action && (cardToPlay.id === 's1' || cardToPlay.id === 's7')) { // Damage spells
                                    potentialTargets = humanPlayer.board.slice().sort((a,b) => b.currentHealth - a.currentHealth); // Target high health first
                                     if (potentialTargets.length > 0) {
                                         targetElement = humanPlayer.boardElement.querySelector(`.card[data-instance-id="${potentialTargets[0].instanceId}"]`);
                                     } else if (cardToPlay.target === 'any') {
                                         targetElement = humanPlayer.heroElement; // Target hero if no creatures
                                     }
                                 } else if (cardToPlay.action && cardToPlay.id === 's2') { // Healing Touch
                                     // Target own damaged hero or creature
                                     const ownDamaged = aiPlayer.board.filter(c=> c.currentHealth < c.health).sort((a,b) => a.currentHealth - b.currentHealth);
                                     if (aiPlayer.heroHealth < STARTING_HEALTH) {
                                         targetElement = aiPlayer.heroElement;
                                     } else if (ownDamaged.length > 0) {
                                         targetElement = aiPlayer.boardElement.querySelector(`.card[data-instance-id="${ownDamaged[0].instanceId}"]`);
                                     } else {
                                          // Maybe target highest health enemy? (For 'any') - less useful
                                     }
                                 } else if (cardToPlay.action && (cardToPlay.id === 's3' || cardToPlay.id === 's6')) { // Buffs
                                      // Target own highest attack creature?
                                     const ownCreatures = aiPlayer.board.slice().sort((a,b) => b.currentAttack - a.currentAttack);
                                     if (ownCreatures.length > 0) {
                                         targetElement = aiPlayer.boardElement.querySelector(`.card[data-instance-id="${ownCreatures[0].instanceId}"]`);
                                     }
                                 }
                                  // Add more specific targeting logic here based on spell effect
                            }

                             if (targetElement || (cardToPlay.target === 'self' || cardToPlay.target === 'opponent-board') ) { // Check if a target was found or not needed
                                 playCard(aiPlayer, cardToPlay, cardIndex, targetElement);
                                 actionFound = true;
                             } else {
                                console.log(`AI could not find suitable target for ${cardToPlay.name}`);
                                // Card remains in hand for now
                             }
                         }
                     }
                 }

                // If no card was played, try to attack
                 if (!actionFound) {
                    const attackers = aiPlayer.board.filter(c => c.canAttack && !c.hasAttacked);
                    if (attackers.length > 0) {
                        const attacker = attackers[0]; // Simple: attack with the first available creature

                         // Basic AI attack targeting:
                         // 1. Attack Taunt creatures
                         // 2. Attack other creatures (prioritize removing threats?)
                         // 3. Attack Hero
                         const opponentTaunts = humanPlayer.board.filter(c => c.isTaunt);
                         let targetElement = null;

                         if (opponentTaunts.length > 0) {
                             // Attack the first taunt minion found
                             targetElement = humanPlayer.boardElement.querySelector(`.card[data-instance-id="${opponentTaunts[0].instanceId}"]`);
                             console.log(`AI ${attacker.name} attacking Taunt: ${opponentTaunts[0].name}`);
                         } else {
                             // Attack a random enemy creature, or hero if none
                            const enemyCreatures = humanPlayer.board;
                            if (enemyCreatures.length > 0) {
                                 // Simple: attack the first enemy creature
                                const targetCreature = enemyCreatures[0];
                                targetElement = humanPlayer.boardElement.querySelector(`.card[data-instance-id="${targetCreature.instanceId}"]`);
                                 console.log(`AI ${attacker.name} attacking creature: ${targetCreature.name}`);
                            } else {
                                 // Attack hero
                                targetElement = humanPlayer.heroElement;
                                 console.log(`AI ${attacker.name} attacking player hero`);
                            }
                         }

                         if (targetElement) {
                             // Use a timeout for visual delay before attacking
                             setTimeout(() => {
                                 if (!state.gameOver && state.currentPlayerId === 'opponent') { // Check game state again before attacking
                                     creatureAttack(attacker, targetElement);
                                     // Check if more actions can be taken after attack
                                     setTimeout(performAIAction, 500); // Check for next action after a short delay
                                 }
                             }, 500); // Delay before attack visualization
                             return; // Exit function early, attack will trigger next check
                         } else {
                            console.log(`AI ${attacker.name} found no valid target.`);
                         }
                    }
                 }

                 // If an action was taken (card played), check again immediately for more actions
                 // Otherwise (no card played, no attack made), end the turn
                 if (actionFound) {
                    setTimeout(performAIAction, 750); // Delay between AI card plays
                 } else {
                     console.log("--- AI Turn End (no more actions) ---");
                     endTurn();
                 }
             }

            // Start the AI action loop
            performAIAction();
        }


        // --- Event Listeners ---
        endTurnButton.addEventListener('click', () => {
            if (state.currentPlayerId === 'player' && !state.targetingMode && !state.gameOver) {
                endTurn();
            }
        });

         restartButton.addEventListener('click', initGame);

         // Add delegated event listeners for targets (opponent board/hero)
         document.getElementById('opponent-board').addEventListener('click', (e) => {
             const targetCardEl = e.target.closest('.card');
             if (targetCardEl) handleTargetClick(targetCardEl);
         });
         document.getElementById('opponent-hero').addEventListener('click', (e) => {
             const heroEl = e.target.closest('.hero-info');
             if (heroEl) handleHeroClick(heroEl);
         });
         // Also allow targeting own hero/board for certain spells
         document.getElementById('player-board').addEventListener('click', (e) => {
              const targetCardEl = e.target.closest('.card');
              // Need to differentiate between selecting own card to attack (handleBoardCardClick)
              // and selecting own card as a target for a spell (handleTargetClick)
               if (targetCardEl && state.targetingMode === 'spell') {
                   handleTargetClick(targetCardEl);
               }
               // handleBoardCardClick is already attached directly in createCardElement
         });
          document.getElementById('player-hero').addEventListener('click', (e) => {
             const heroEl = e.target.closest('.hero-info');
             if (heroEl && state.targetingMode === 'spell') {
                  handleHeroClick(heroEl);
             }
         });

        // --- Initialize Game ---
        document.addEventListener('DOMContentLoaded', initGame);

    </script>

</body>
</html>